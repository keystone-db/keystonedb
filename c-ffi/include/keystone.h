/* KeystoneDB C API */
/* Auto-generated - do not edit */


#ifndef KEYSTONE_H
#define KEYSTONE_H

#pragma once

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// Error codes returned by FFI functions
typedef enum ks_error_t {
  // Operation succeeded
  Ok = 0,
  // Null pointer argument
  NullPointer = 1,
  // Invalid UTF-8 string
  InvalidUtf8 = 2,
  // Invalid argument
  InvalidArgument = 3,
  // I/O error
  IoError = 4,
  // Item not found
  NotFound = 5,
  // Internal error
  Internal = 6,
  // Corruption detected
  Corruption = 7,
  // Conditional check failed
  ConditionalCheckFailed = 8,
} ks_error_t;

// Opaque handle to a Database instance
typedef struct ks_database_t {
  uint8_t _private[0];
} ks_database_t;

// Opaque handle to an Item
typedef struct ks_item_t {
  uint8_t _private[0];
} ks_item_t;

// Create a new database at the specified path
//
// # Arguments
// * `path` - Path to database directory (null-terminated C string)
// * `out` - Output pointer to receive database handle
//
// # Returns
// Error code (0 = success)
//
// # Safety
// Caller must ensure path is a valid null-terminated string
enum ks_error_t ks_database_create(const char *path, struct ks_database_t **out);

// Open an existing database at the specified path
//
// # Arguments
// * `path` - Path to database directory (null-terminated C string)
// * `out` - Output pointer to receive database handle
//
// # Returns
// Error code (0 = success)
//
// # Safety
// Caller must ensure path is a valid null-terminated string
enum ks_error_t ks_database_open(const char *path, struct ks_database_t **out);

// Create a new in-memory database
//
// # Arguments
// * `out` - Output pointer to receive database handle
//
// # Returns
// Error code (0 = success)
enum ks_error_t ks_database_create_in_memory(struct ks_database_t **out);

// Close and free a database handle
//
// # Arguments
// * `db` - Database handle to close
//
// # Safety
// Caller must ensure db is a valid database handle and is not used after this call
void ks_database_close(struct ks_database_t *db);

// Put a string value into the database
//
// # Arguments
// * `db` - Database handle
// * `pk` - Partition key (null-terminated C string)
// * `sk` - Sort key (null-terminated C string, or NULL for no sort key)
// * `attr_name` - Attribute name (null-terminated C string)
// * `value` - String value (null-terminated C string)
//
// # Returns
// Error code (0 = success)
//
// # Safety
// All string pointers must be valid null-terminated C strings
enum ks_error_t ks_database_put_string(struct ks_database_t *db,
                                       const char *pk,
                                       const char *sk,
                                       const char *attr_name,
                                       const char *value);

// Get an item from the database
//
// # Arguments
// * `db` - Database handle
// * `pk` - Partition key (null-terminated C string)
// * `sk` - Sort key (null-terminated C string, or NULL for no sort key)
// * `out` - Output pointer to receive item handle (NULL if not found)
//
// # Returns
// Error code (0 = success, NotFound if item doesn't exist)
//
// # Safety
// Caller must free the returned item with ks_item_free
enum ks_error_t ks_database_get(struct ks_database_t *db,
                                const char *pk,
                                const char *sk,
                                struct ks_item_t **out);

// Delete an item from the database
//
// # Arguments
// * `db` - Database handle
// * `pk` - Partition key (null-terminated C string)
// * `sk` - Sort key (null-terminated C string, or NULL for no sort key)
//
// # Returns
// Error code (0 = success)
enum ks_error_t ks_database_delete(struct ks_database_t *db, const char *pk, const char *sk);

// Free an item handle
//
// # Arguments
// * `item` - Item handle to free
//
// # Safety
// Caller must ensure item is not used after this call
void ks_item_free(struct ks_item_t *item);

// Get the last error message
//
// # Returns
// Null-terminated C string with error message, or NULL if no error
//
// # Safety
// The returned pointer is valid until the next FFI call on this thread
const char *ks_get_last_error(void);

#endif  /* KEYSTONE_H */
